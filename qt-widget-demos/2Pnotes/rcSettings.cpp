/* FILE: rcSettings.cpp    V 0.2.2

   rcSettings contains the class to create and manage a resource file
   which includes the user settings of a program. The name of the file
   is automatically generated by the name of the application followed
   by 'rc'. It is saved in the home directory of the user.

   This class is written using the qt 4.4 library.
   
     Copyright (C) 2002, 2007,2009  J. Schulze-Wenck
            message@jschulze-wenck.de

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include "rcsettings.h"

rcSettings::rcSettings(QString nameOfApplication)
{
   // setting versions for internal use only
   version="0.22";
   filever="0.1";

   filename=nameOfApplication+"rc";
   file=QDir::homePath()+'/'+filename;
   //convert separators for the underlying operating system.
   file=QDir::toNativeSeparators(file);
   f.setFileName(file);
   if(f.exists())
   {
      bool found=false;
      QString t;

      if(f.open(QIODevice::ReadOnly))
      {
         QTextStream r(&f);

         while(!r.atEnd())
            l.append(r.readLine()+"\n");

         f.close();

         // check the version of file
         t=rcReadStrValue(&found, "private", "rcSetting_fileVersion");
         
         if(!found || (t.compare(filever)!=0))  // wrong version
         {
            QMessageBox::warning(0, filename.left(filename.length()-2),
                        (QObject::tr("You have a wrong version of the ressourcefile\n\n")
                                     +file+"\n\n"+
                                QObject::tr("Delete or rename this file. The application\n")+
                        QObject::tr("is closed now.")));
            exit(-1);
         }
      }
      else
         QMessageBox::information(0, filename.left(filename.length()-2),(
                                     QObject::tr("Can not open")+"\n"+file+"\n"+
                                     QObject::tr("Using defaults.")));
   }
   else //create an empty resource file with an information text
   {
      createNewList();
      rcsave();
   }
}

void rcSettings::rcSetStrValue(QString group, QString vname, QString value)
// group = name without separator ':-)', if not exists it will be created
// vname = name of variable without separator '=', if not exists it will be created
// value = textstring or string converted number, depend on the application
{
   QStringList::iterator it_group;
   QStringList::iterator it_nextGroup;
   QStringList::iterator it_vname;
   QString t_group, t_vname;

   t_group=":-)"+group+'\n';
   t_vname=vname+'=';

   // search group
   if((it_group=findGroup(t_group))==l.end())   //group not found
    {
      l.append(t_group);    //create group item
        it_group=l.end();
    }

   it_nextGroup=nextGroup(it_group);    //may be end()

   // search vname
   if((it_vname=findVariableName(t_vname, it_group, it_nextGroup))==it_nextGroup)
   //vname not found, create vname item
    it_vname=l.insert(it_nextGroup, t_vname);

   // set value
   (*it_vname).truncate(0); //remove old value
   (*it_vname)=t_vname+value+'\n';  //set new value

   rcsave();
}

void rcSettings::rcSetNumValue(QString group, QString vname, long value)
// group = name without separator ':-)', if not exists it will be created
// vname = name of variable without separator '=', if not exists it will be created
// value = long, dependet on the application
// this function interprets value as a decimal number
// and convert it into a string. Then calls the string type of rcSetValue()
{
   QString s;

   rcSetStrValue(group, vname, s.setNum(value));
}

QString rcSettings::rcReadStrValue(bool* found, QString group, QString vname)
// returns the string value of the variable vname.
// when function return, is bool found = true, if the value is valid
// group = name without separator ':-)'
// vname = name of variable without separator '='
{
   QString value, t_group, t_vname;
   QStringList::iterator it, it_group, it_nextGroup;

   *found=false;
   t_group=":-)"+group+'\n';
   t_vname=vname+'=';

   // search group
   if((it_group=findGroup(t_group))==l.end())   //group not found
   {
      //qWarning("func rcReadStrValue: group not found.");
      value="";
   }
   else
   {
      it_nextGroup=nextGroup(it_group); //may be end()

      // search vname
      if((it=findVariableName(t_vname, it_group, it_nextGroup))==it_nextGroup)
      // vname not found
      {
         //qWarning("func rcReadStrValue: vname not found.");
         value="";
      }
      else //group and vname found, read value
      {
         uint l_value;

         l_value=(*it).length()-t_vname.length();
         value=(*it).right(l_value);
         value.truncate(l_value-1); //cut the '\n' at end of string
         if(!value.isEmpty())
            *found=true;
      }
   }
   return value;
}

long rcSettings::rcReadNumValue(bool* found, QString group, QString vname)
// group = name without separator ':-)'
// vname = name of variable without separator '='
// this function returns the value as a decimal number
// Internally it calls rcReadValue()
// found must be true, if value is valid
{
   QString s;
   long i=0;;
   bool ok=true;

   s=rcReadStrValue(found, group, vname);
   if(found)
      i=s.toLong(&ok);

   if(!ok)
   {
      //qWarning("func rcReadNumValue: value is not a valid integer");
      *found=false; // s is not a valid number
   }
   return i;
}

bool rcSettings::rcdelVariable(QString group, QString vname)
// group = name without separator ':-)'
// vname = name of variable without separator '='
// deletes the variable vname and the value of vname
// return true if successful or false, if vname or group is not found
{      
   QStringList::iterator it_group;
   QStringList::iterator it_nextGroup;
   QStringList::iterator it_vname;
   QString t_group, t_vname;

   t_group=":-)"+group+'\n';
   t_vname=vname+'=';

   // search group
   if((it_group=findGroup(t_group))==l.end())   //group not found
      return false;

   it_nextGroup=nextGroup(it_group);    //may be end()

   // search vname
   if((it_vname=findVariableName(t_vname, it_group, it_nextGroup))==it_nextGroup)
   //vname not found
      return false;

   // delete vname
   l.erase(it_vname);

   rcsave();
   return true;
}

bool rcSettings::rcdelGroup(QString group)
// group = name without separator ':-)'
// deletes all members of a group and at least the groupname.
{
   QStringList::iterator it_group;
   QStringList::iterator it_next;
   QString t_group;

   t_group=":-)"+group+'\n';

   // search group
   if((it_group=findGroup(t_group))==l.end())   //group not found
      return false;

   // delete members, if there are some
   it_next=it_group;
   it_next++;
   if(((*it_next).contains(":-)")==0) && (it_next!=l.end()))
   {
      do
      {
         it_next=l.erase(it_next);
        
      }while(((*it_next).contains(":-)")==0) && (it_next!=l.end()));
   }

   // delete group
   l.erase(it_group);

   rcsave();
   return true;
}

QStringList::iterator rcSettings::findGroup(QString group)
// returns the iterator of the first string "group" in the
// QStringList or l.end() if group is not found
{
    QStringList::iterator it;
    
    for(++(it=l.begin()); it!=l.end(); ++it)
    {
        if((*it).contains(group)!=0)
            break;
    }

    return it;
}

QStringList::iterator rcSettings::nextGroup(QStringList::iterator start)
// returns the index of the following group name
// or end(), if there is no following group
{
   QStringList::iterator it;

   if(start != l.end())
   {
    for(++(it=start); it!=l.end(); ++it)
    {
         if((*it).contains(":-)")!=0)
            break;
        }
   }
   else
    return l.end();

   return it;
}

QStringList::iterator rcSettings::findVariableName(QString vname, QStringList::iterator start, QStringList::iterator stopp)
// returns the iterator of the first string "vname" in the
// QStringList or stopp if vname is not found
{
   QStringList::iterator it;

   //search vname
   for(it=start; it!=stopp; ++it)
   {
      if((*it).contains(vname)!=0)  //vname found
         break;
   }

   return it;
}

void rcSettings::createNewList(void)
{
   l.append("# This is a generated file.\n");
   l.append("# Created with rcSettings "+version+
            " for the application "+filename.left(filename.length()-2)+'.'+'\n');
   l.append("# (c) 2002 - 2009, J. Schulze-Wenck, http://www.jschulze-wenck.de\n");
   l.append("# You may feel better, if you don't edit it!\n");
   l.append("#\n");
   l.append(":-)private\n");
   l.append("rcSetting_fileVersion="+filever+'\n');
   l.append("#\n");
}

void rcSettings::rcsave(void)
{
    if(f.open(QIODevice::WriteOnly))
    {
      QTextStream r(&f);
      QStringList::iterator it;

      for(it=l.begin(); it != l.end(); ++it)
         r<<*it;
         
      f.close();
   }
   else
    QMessageBox::information(0, filename.left(filename.length()-2),
                               QObject::tr("Can not write to file")+"\n"+file);
}

